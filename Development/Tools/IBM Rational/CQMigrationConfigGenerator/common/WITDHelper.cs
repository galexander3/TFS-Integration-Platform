// Copyright © Microsoft Corporation.  All Rights Reserved.
// This code released under the terms of the 
// Microsoft Public License (MS-PL, http://opensource.org/licenses/ms-pl.html.)

// Description: Helper Class to support Currituck Schema XML file Read/Write

#region Using directives

using System;
using System.IO;
using System.Text;
using System.Xml;
using System.Xml.Serialization;
using System.Collections.Generic;
using System.Diagnostics;
using Microsoft.TeamFoundation.Converters.Utility;
using System.Collections;
using System.Reflection;
using Microsoft.TeamFoundation.Converters.WorkItemTracking;
using Microsoft.TeamFoundation.Converters.Reporting;
#endregion

/*
 * Whenever there is a change in WorkItemTypeDefinition.xsd, please follow these steps:
 * 1. Regenerate the WorkItemTypeDefinition.cs file using xsd.exe.
 * 2. For every usage of array [], 
 *  a) Replace the private member and public property type to ArrayList.
 *  b) Check for the XML attribute defined above the public property. You will find one of these attributes:
 *      XmlArrayItemAttribute or XmlElementAttribute. 
 *      In definition of these attributes, add Type = typeof(<class type>) where class type is the class name
 *      for which you changed Class1[] to ArrayList.
 *  c) In Parallel to each public property (returning ArrayList) create similar property with [XmlIgnore] attribute.
 *      Implemet only get() call and in that call return the original property is ArrayList is not null otherwise
 *      initialize the ArrayList and return that. This step can be ignored if you are ok with the empty element
 *      definitions (for ex <States />) if there are no child elements. In this case just initialize the ArrayList
 *      at the time of declaration itself.
 * 
 */
namespace Microsoft.TeamFoundation.Converters.WorkItemTracking.Common
{
    /// <summary>
    /// Adding to all the required Classes generated by XSD tool. This interface will allow the programmers
    /// to populate the entire XML schema in any order. This do not require the prog. to know the no 
    /// of elements in advance. To avoid that new methods has been added in the classes and internally
    /// they will be stored in some collection. Finally at the time of generating XML file, all the 
    /// collection objects will be moved to the corresponding Arrays.
    /// </summary>

    /// <remarks>
    /// Extending the structure.
    /// </remarks>
    public class WITDSchema
    {
        #region PRIVATE MEMBERS
        private static VSTSConnection m_vstsConn;
        # endregion

        [XmlIgnore]
        public static VSTSConnection VstsConn
        {
            get { return m_vstsConn; }
            set { m_vstsConn = value; }
        }

        private Witd witd;

        public WITDSchema()
        {
            witd = new Witd();
        }

        /// <summary>
        ///  Creates the Currituck Schema XML file
        /// </summary>
        /// <param name="schemaFile">Schema file name</param>
        public void GenerateWITDSchema(string schemaFile)
        {
            // before starting the serialization, add the internal required field
            // by all the converters in the fields
            CreateInternalFields(witd.WORKITEMTYPE);

            try
            {
                // write the xml file. The using statement will close the file.
                using (TextWriter tw = new StreamWriter(schemaFile))
                {
                    XmlSerializer sr = new XmlSerializer(typeof(Witd));

                    // serialize the XML file
                    Logger.WritePerf(LogSource.Common, "Begining serialization of {0}", schemaFile);
                    sr.Serialize(tw, witd);
                    Logger.WritePerf(LogSource.Common, "Serialization of {0} done", schemaFile);
                }

                // load the WITD xml file and add pre defined form section
                // get xml node for new form section to be added
                string formToAdd;
                using (StreamReader stream = new StreamReader(Assembly.GetExecutingAssembly().GetManifestResourceStream("CQConverter.common.FixedForm.xml")))
                {
                    formToAdd = stream.ReadToEnd();
                }

                // get xmldoc node for wit definition
                XmlDocument formDoc = UtilityMethods.LoadFileAsXmlDocument(schemaFile);

                XmlDocumentFragment formDocFrag = formDoc.CreateDocumentFragment();
                formDocFrag.InnerXml = formToAdd;

                XmlNamespaceManager nsm = new XmlNamespaceManager(formDoc.NameTable);
                nsm.AddNamespace("CQ", CommonConstants.WITDTypesNamespace);

                // find the node after which the aditional form has to be added
                XmlNode form = formDoc.SelectSingleNode("//CQ:WITD/WORKITEMTYPE/FORM/Layout", nsm);
                Debug.Assert(form != null, string.Format("Null FORM element while looking for WITD/WORKITEMTYPE/FORM/Layout in {0}", schemaFile));
                form.InsertAfter(formDocFrag, form.LastChild);

                UtilityMethods.ValidateXmlFragment(schemaFile, formDoc.LastChild, CommonConstants.WITDXsdFile);
                
                // write the modified schema file back
                XmlTextWriter writer = new XmlTextWriter(schemaFile, null);
                writer.Formatting = Formatting.Indented;
                formDoc.Save(writer);
                writer.Close();
            }
            // handle the problems occured during serializing the xml file
            catch (IOException e) // for filenotfound, directorynotfound and such io realted exceptions
            {
                Logger.WriteException(LogSource.Common, e);
                throw;
            }
            catch (System.Runtime.Serialization.SerializationException e)
            {
                Logger.WriteException(LogSource.Common, e);
                throw;
            }
        }

        /// <summary>
        /// Creates the internal fields required by all the converters while generating the schema file
        /// </summary>
        /// <param name="wit"></param>
        private void CreateInternalFields(WorkItemType wit)
        {
            // fields required in all the schema generated
            string[] mandatoryFields = {
                "Migration Status"
            };

            foreach (string internalFldName in mandatoryFields)
            {
                FieldDefinition internalFld = new FieldDefinition();
                internalFld.name = internalFldName;
                internalFld.type = FieldType.String;
                wit.AddField(internalFld);
            }
        }

        /// <summary>
        /// Set the Application Name
        /// </summary>
        /// <param name="app"></param>
        /// <returns>true is success else false</returns>
        public void SetApplication(Application app)
        {
            Logger.Write(LogSource.Common, TraceLevel.Info, "Setting Application: {0}", app);
            witd.application = app;
            witd.applicationSpecified = true;
        }


        /// <summary>
        /// Set a new Work Item Type in the Schema
        /// We can have more than one WIT in a XML file
        /// </summary>
        /// <param name="wiType"></param>
        /// <returns>true is success else false</returns>
        public void SetWorkItemType(WorkItemType wiType)
        {
            Debug.Assert(wiType != null);
            if (wiType != null)
            {
                Logger.Write(LogSource.Common, TraceLevel.Info, "Setting Work Item Type {0}", wiType);
                witd.SetWorkItemType(wiType);
                return;
            }

            Logger.Write(LogSource.Common, TraceLevel.Error, "Attempt to add NULL WIT in WITD");
        }
    }


    /// <remarks>
    /// Extending the structure of class representing the Work Item Type Definition
    /// This is the root element in the xml schema.
    /// </remarks>
    public partial class Witd
    {
        public Witd()
        {
        }

        /// <summary>
        /// Add a WIT in current Schema
        /// </summary>
        /// <param name="wiType">Work Item Type</param>
        /// <returns>true is success else false</returns>
        public void SetWorkItemType(WorkItemType wiType)
        {
            Debug.Assert(wiType != null);
            if (wiType != null)
            {
                this.WORKITEMTYPE = wiType;
                return;
            }

            Logger.Write(LogSource.Common, TraceLevel.Error, "Attempt to add NULL WIT in WITD");
        }
    }

    public partial class Form
    {
        public Form()
        {
            layoutField = new LayoutType();
        }
    }

    public partial class Transition
    {
        public Transition()
        {
            REASONS = new Reasons();
        }
    }


    /// <remarks>
    /// Extending the structure of class representing individual Work Item Type.
    /// </remarks>
    public partial class WorkItemType
    {
        #region Private Members
        // maintains all the field names which are already used in the current schema
        private Hashtable usedFieldNames;
        private Hashtable usedFieldRefNames;
        private static Dictionary<string, FieldDefinition> usedFiledNameDefs
            = new Dictionary<string,FieldDefinition>(TFStringComparer.OrdinalIgnoreCase);
        #endregion

        public WorkItemType()
        {
            usedFieldNames = new Hashtable(TFStringComparer.OrdinalIgnoreCase);
            usedFieldRefNames = new Hashtable(TFStringComparer.WIConverterFieldRefName);
        }

        /// <summary>
        /// Adds a Field in Work Item Type
        /// </summary>
        /// <param name="fieldDef">Field to be added</param>
        /// <returns>true is success else false</returns>
        public void AddField(FieldDefinition fieldDef)
        {
            Debug.Assert(fieldDef != null);

            VSTSUtil.CheckFieldTypeCollision(this.name, ref fieldDef, usedFiledNameDefs);

            VSTSUtil.ValidateFieldNames(WITDSchema.VstsConn, ref fieldDef, usedFieldNames, usedFieldRefNames);
            
            if (fieldDef != null)
            {
                // add the current field name in usedFieldNames
                usedFieldNames[fieldDef.name] = true;
                usedFieldRefNames[fieldDef.refname] = true;
                usedFieldRefNames[fieldDef.name] = fieldDef;

                Logger.Write(LogSource.Common, TraceLevel.Info,
                    "Adding field {0} in {1}", fieldDef.name, name);
                WITDFIELDS.Add(fieldDef);
                return;
            }

            Logger.Write(LogSource.Common, TraceLevel.Error, "Attempt to add NULL Field in WIT {0}", name);
        }

        /// <summary>
        /// Adds a global list definition Work Item Type
        /// </summary>
        /// <param name="fieldDef">Field to be added</param>
        /// <returns>true is success else false</returns>
        public void AddField(GlobalListDef globalListDef)
        {
            Debug.Assert(globalListDef != null);
            if (globalListDef != null)
            {
                Logger.Write(LogSource.Common, TraceLevel.Info,
                    "Adding Global Definition Field {0} in {1}", globalListDef.name, name);
                WITDGLOBALLISTS.Add(globalListDef);
                return;
            }

            Logger.Write(LogSource.Common, TraceLevel.Error, "Attempt to add NULL Global List Definition Field in {0}", name);
        }

        /// <summary>
        /// Find the given field in the FIELDS section of Wotk Item Type Definition
        /// </summary>
        /// <param name="fldName">Name of the field to look for</param>
        /// <returns>Control handle if the field exists, null otherwise</returns>
        public ControlType FindFieldInForm(string fldRefName, out int pos)
        {
            Debug.Assert(!String.IsNullOrEmpty(fldRefName), "Null field name to lookup in WITD FORM");
            if (FORM != null && FORM.Layout != null)
            {
                int index;
                ControlType ctrl = null;
                for (index = 0; index < FORM.Layout.WITDItems.Count; index++)
                {
                    ctrl = (ControlType)FORM.Layout.WITDItems[index];
                    if (TFStringComparer.WIConverterFieldRefName.Equals(fldRefName, ctrl.FieldName))
                    {
                        pos = index;
                        return ctrl;
                    }
                }
            }
            pos = -1;
            return null;
        }
    }
    

    public partial class FieldDefinition
    {
        private string m_oldFieldName;
        [XmlIgnore]
        public string OldFieldName
        {
            get { return m_oldFieldName; }
            set { m_oldFieldName = value; }
        }
    }
}
