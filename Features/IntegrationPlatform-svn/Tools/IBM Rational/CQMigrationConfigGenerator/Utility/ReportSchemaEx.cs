// Copyright © Microsoft Corporation.  All Rights Reserved.
// This code released under the terms of the 
// Microsoft Public License (MS-PL, http://opensource.org/licenses/ms-pl.html.)

#region Using directives

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Globalization;
using System.IO;
using System.Xml;
using System.Xml.Serialization;

using Microsoft.TeamFoundation.Converters.Utility;
using System.Threading;

#endregion

//This is a backup of the steps to be done on ReportSchema.cs after its generation.
//Changes to be made after generating ReportSchemacs file from Xsd.exe
//Add namespace 
//Make the classes ReportSummary, ReportStatistics, ReportSummaryTarget, ReportFile and ReportSummarySource partial.
//Make the class ReportStatistics, ReportSummaryTarget and ReportSummarySource empty. They are being implemented in XmlReporter.cs
//


namespace Microsoft.TeamFoundation.Converters.Reporting
{

    /// <summary>
    /// The serialization attributes are set for these partial classes in the autogenerated code. So no need of doing it here also.
    /// </summary>
    public partial class ReportFile
    {
        // A default constrcutor.
        public ReportFile()
        {
            Debug.Assert(false, "This constructor should not have been called"); // Is there a better way of indicating this???
            // This constructor should not be used. This is present only to satisfy the serialization condition that a default constructor shouled be present for each class.
        }
        // Returns an object of the type Report file.
        public ReportFile(string name, string value)
        {
            nameField = name;
            valueField = value;
        }
    }

    /// <summary>
    /// This part of the definition is used for defining the sourceanddestination node in the summary
    /// </summary>
    public partial class ReportSummary
    {
        /// <summary>
        /// public constructor. Required for serialization.
        /// </summary>
        public ReportSummary()
        {
            sourceAndDestinationField = new ReportSummarySourceAndDestination();
            TypeOfMigration = ReportSummaryTypeOfMigration.Full;
            sourceActionEndTimeField = string.Empty;
            sourceActionStartTimeField = string.Empty;
        }
    }

    /// <summary>
    /// This part of the definition defines the constructors and other additional methods for adding nodes into the report
    /// </summary>
    public partial class Report
    {

        /// <summary>
        /// This default constructor is required for serialization.
        /// </summary>
        public Report()
        {
        }

        /// <summary>
        /// Constructor with the filename as input.
        /// </summary>
        /// <param name="fname"></param>
        public Report(string fileName)
        {
            Debug.Assert(fileName != null, "Report file is null");     // To eliminate ArgumentNullException during deserialization.
            Debug.Assert(fileName.Length != 0, "Report file is empty"); // To eliminate Argumentexception during deserialization.
            m_fileName = fileName;
            issuesField = new ArrayList();
            outputField = new ArrayList();
            versionField = "1.1.0";   // version of the xsd used.
            summaryField = new ReportSummary();
            statisticsField = new ReportStatistics();
            userInputField = new ReportUserInput();
        }

        public string ReportFileName
        {
            get { return m_fileName; }
            // no set function.. cannot be set later
        }

        #region Public Methods
        /// <summary>
        ///  Public methods called during the migration process for logging messages into the report and finally writing it to file
        /// </summary>
        /// Add an issue to the report.
        public void AddIssue(ReportIssue rep)
        {
            issuesField.Add(rep);
        }

        #region Writing Errros


        #endregion

        #region Writing Generic issues

        /// <summary>
        /// This takes in IssueId, Type of the issue and the Issue Message as input
        /// </summary>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        virtual public void WriteIssue(string id, ReportIssueType type, string message)
        {
            WriteIssue(id, type, message, null, null);
        }

        /// <summary>
        /// This method takes issueid, type, message and the itemname as input.
        /// </summary>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="message"></param>
        /// <param name="item"></param>
        virtual public void WriteIssue(string id, ReportIssueType type, string message, string item)
        {
            WriteIssue(id, type, message, item, null);
        }

        /// <summary>
        /// This is the method to write and issue into the report. This takes the parameters in the issue node
        /// </summary>
        /// <param name="id"></param>
        /// <param name="type"></param>
        /// <param name="details"></param>
        /// <param name="itemName"></param>
        /// <param name="location"></param>
        /// <param name="additionalInfos"></param>
        virtual public void WriteIssue(string id, ReportIssueType type, string details, string itemName, string location, params string[] additionalInfoList)
        {
            WriteIssue(id,  details, itemName, location, null, type,additionalInfoList);
        }

        /// <summary>
        /// This is the method to write and issue into the report. This takes the parameters in the issue node
        /// </summary>
        /// <param name="id">Issue Id</param>
        /// <param name="type">Issue Type</param>
        /// <param name="details">Actual Isssue Message</param>
        /// <param name="itemName">Issue Item</param>
        /// <param name="location">Issue Location</param>
        /// <param name="group">Issue Group/Category</param>
        /// <param name="additionalInfos">Other Additional Info</param>
        virtual public void WriteIssue(string id, 
                                       string details, 
                                       string itemName, 
                                       string location,
                                       string group,
                                       ReportIssueType type, 
                                       params string[] additionalInfoList
                                      )
        {
            //What will happen if id/message/type is null?
            ReportIssue issue = new ReportIssue();
            issue.IssueID = id;
            issue.Type = type;
            issue.Message = details;
            issue.Group = group;
            if (additionalInfoList != null && additionalInfoList.Length > 0)
            {
                issue.AdditionalInfos = additionalInfoList;
            }

            issue.Item = itemName;
            issue.Location = location;
            // Increment the corresponding counter 
            switch (type)
            {
                // If this issue is an critical error, set the flag
                // as there can be only one Critical Error
                case ReportIssueType.Critical:
                    // debug check to see that this should'nt occur more than once
                    Debug.Assert(statisticsField.HasCriticalError == false, "Trying to add more than one critical error");
                    statisticsField.HasCriticalError = true;
                    m_criticalError = issue.Message;
                    break;
                // If this issue is an error, increment the numberoferrors
                case ReportIssueType.Error:
                    statisticsField.NumberOfErrors++;
                    break;
                // if this issue is a warning, increment the numberofwarnings
                case ReportIssueType.Warning:
                    statisticsField.NumberOfWarnings++;
                    break;
            }

            AddIssue(issue);
        }

        #endregion

        /// <summary>
        /// Method to add an output entry. 
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        public void AddOutput(string name, string value)
        {
            Output.Add(new ReportFile(name, value));
        }

        /// <summary>
        /// This method will set the starting time for the report
        /// Possible exceptions that can be thrown from this method are
        /// 
        /// ConverterException
        /// </summary>
        public void StartReporting(ReportConverter converter)
        {
            Logger.EnteredMethod(LogSource.Common);

            try
            {
                m_writer = new StreamWriter(m_fileName);
            }
            catch (Exception e) // catch all
            {
                Logger.WriteException(LogSource.Common, e);
                throw new ConverterException(e.Message, e);
            }

            // Start the time in the summary node here
            m_startDateTime = DateTime.Now;
            summaryField.StartTime = m_startDateTime.ToString(CultureInfo.CurrentCulture);

            Type = ReportType.PreMigration;
            Title = CommonResource.AnalysisReportTitle;
            
            // Setting converter specific properties here
            switch (converter)
            {
                case ReportConverter.VSSConverter:
                    Converter = ReportConverter.VSSConverter;
                    SourceSystem = ReportSourceSystem.VSS;
                    TargetSystem = ReportTargetSystem.VersionControl;
                    break;

                case ReportConverter.SDConverter:
                    Converter = ReportConverter.SDConverter;
                    SourceSystem = ReportSourceSystem.SD;
                    TargetSystem = ReportTargetSystem.VersionControl;
                    break;

                case ReportConverter.PSConverter:
                    Converter = ReportConverter.PSConverter;
                    SourceSystem = ReportSourceSystem.PS;
                    TargetSystem = ReportTargetSystem.WorkItemTracking;
                    break;

                case ReportConverter.CQConverter:
                    Converter = ReportConverter.CQConverter;
                    SourceSystem = ReportSourceSystem.ClearQuest;
                    TargetSystem = ReportTargetSystem.WorkItemTracking;
                    break;

                default:
                    Debug.Fail("Invalid ReportConverter type");
                    break;
            }

            Logger.ExitingMethod(LogSource.Common);
        }

        /// <summary>
        /// This method is used to generate the xml file using xmlserializer
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="generateSupportFiles"></param>
        void GenerateXml(StreamWriter writer, bool generateSupportFiles)
        {
            int retryCount = ErrorRetryCount;
            while (retryCount>0)
            {
                try
                {
                    using (XmlTextWriter xmlwriter = new XmlTextWriter(writer))
                    {
                        XmlSerializer x = new XmlSerializer(typeof(Report));
                        xmlwriter.Formatting = Formatting.Indented;
                        if (generateSupportFiles)
                        {
                            string str = "version=\"1.0\" encoding=\"utf-8\"";
                            xmlwriter.WriteProcessingInstruction("xml", str);
                            str = "type='text/xsl' href='" + Report.SupportFileDirectory + "\\" + Report.StyleSheetFile + "'";
                            xmlwriter.WriteProcessingInstruction("xml-stylesheet", str);
                        }
                        x.Serialize(xmlwriter, this);
                    }
                    break;
                }
                catch (ThreadAbortException)
                {
                    throw;
                }
                // what ever exception keep retrying report should be generated
                catch (Exception e)
                {
                    retryCount--;
                    Logger.WriteException(LogSource.Common, e);
                    UtilityMethods.RetryDiskFull(ReportFileName);
                }
            }
        }

        /// <summary>
        /// This method takes the stylesheet filename as input
        /// </summary>
        /// <param name="styleSheetFileName"></param>
        public void EndReporting(bool generateSupportFiles)
        {
            Logger.EnteredMethod(LogSource.Common);
            if (m_writer == null)
            {
                Logger.Write(LogSource.Common, TraceLevel.Error, "The method EndReporting called without calling StartReporting");
                return;
            }

            // Check if the file is already generated before.
            if (!triedOnce)
            {
                if (summaryField.Status == null)
                {
                    summaryField.Status = CommonResource.ProcessIncomplete;
                }

                DateTime endDateTime = DateTime.Now;
                summaryField.EndTime = endDateTime.ToString(CultureInfo.CurrentCulture);
                TimeSpan totalTime = endDateTime.Subtract(m_startDateTime);

                //Do not report milliseconds
                int days = totalTime.Days;
                int hours = totalTime.Hours;
                int mins = totalTime.Minutes;
                int seconds = totalTime.Seconds;

                totalTime = new TimeSpan(days, hours, mins, seconds);
                summaryField.TotalTime = totalTime.ToString();

                // I dont know if this will be an issue for glob/loc. I dont think so.
                this.RunBy = Environment.UserDomainName + Path.DirectorySeparatorChar + Environment.UserName;
                
                try
                {
                    GenerateXml(m_writer, generateSupportFiles);
                    triedOnce = true;
                }
                finally
                {
                    m_writer.Close();
                    if (generateSupportFiles)
                    {
                        //Create the directory first;
                        FileInfo info = new FileInfo(m_fileName);
                        string parentPath = info.Directory.FullName;
                        string outputDirName = Path.Combine(parentPath, Report.SupportFileDirectory);
                        UtilityMethods.CreateDirectory(outputDirName);
                        //Then copy the files
                        foreach (string str in Report.SupportFiles)
                        {
                            UtilityMethods.CopyFromAssemblyToDestination(str, Path.Combine(outputDirName, str));
                        }
                    }

                    // If the previous attempt to write failed
                    // Write the report into the new backup file
                    // Any exceptions here would be propagated to the caller!!
                    if (!triedOnce)
                    {
                        triedOnce = true;
                        m_backupFileName = Path.GetTempPath() + "MigrationReport.xml"; // The name of the file is not yet finalized in spec.
                        m_fileName = m_backupFileName; // Set the file name to the new name
                        GenerateXml(new StreamWriter(m_backupFileName), generateSupportFiles);
                    }
                }
            }

#if DEBUG
            //only in debug mode validate the generated xml file against the reportschema xsd file.
            try
            {
                UtilityMethods.ValidateXmlFile(m_fileName, m_xsdFileName);
            }
            catch (ConverterException e)
            {
                Logger.WriteException(LogSource.Common, e);
                UtilityMethods.DisplayError("The generated Report file does not comply with the xsd file");
            }
#endif

            Logger.ExitingMethod(LogSource.Common);
        }

        #endregion

        #region properties

        /// <summary>
        /// Returns the number of issues in the report.
        /// </summary>
        public int IssueCount
        {
            get { return Issues.Count; }
        }

        public static string SupportFileDirectory
        {
            get { return m_supportFilesDirectory; }
        }

        public static string[] SupportFiles
        {
            get { return m_supportFiles; }
        }

        public static string StyleSheetFile
        {
            get { return m_styleSheetFile; }
        }

        public string CriticalError
        {
            get { return m_criticalError; }
        }
        #endregion

        #region Additional private fields

        private const int ErrorRetryCount = 4;
        private DateTime m_startDateTime;
        private string m_fileName;
        private StreamWriter m_writer;
        private string m_criticalError;

        private static bool triedOnce = false;
        private static string m_backupFileName;
        private static readonly string m_styleSheetFile = "CQConverter.Utility.ReportOutput.xslt";
        private static readonly string m_supportFilesDirectory = "_MigrationReport_Files";
        private static readonly string[] m_supportFiles = new string[] { "CQConverter.Utility.UpgradeReport_Plus.gif",
                                                 "CQConverter.Utility.UpgradeReport_Minus.gif",
                                                 "CQConverter.Utility.UpgradeReport.css",
                                                 m_styleSheetFile
        };

#if DEBUG
        private static readonly string m_xsdFileName = "CQConverter.Utility.ReportSchema.xsd";
#endif

        #endregion
    }
}
